// Automatically generated from template - EDITS WILL BE LOST

// Generated by binval.awk with options define binvald

#ifndef __Header_binvald__
#define __Header_binvald__

char *
BinaryValueDescription_Zero(Uint16 value)
{
	ostrstream ost;
	switch (value) {
		case 0x0000:
			ost << "0x0000" << ends;
			return ost.str();
		default:
			return 0;
	}
}

char *
BinaryValueDescription_One(Uint16 value)
{
	ostrstream ost;
	switch (value) {
		case 0x0001:
			ost << "0x0001" << ends;
			return ost.str();
		default:
			return 0;
	}
}

char *
BinaryValueDescription_Three(Uint16 value)
{
	ostrstream ost;
	switch (value) {
		case 0x0003:
			ost << "0x0003" << ends;
			return ost.str();
		default:
			return 0;
	}
}

char *
BinaryValueDescription_FFFF(Uint16 value)
{
	ostrstream ost;
	switch (value) {
		case 0xffff:
			ost << "Inconsistencies may be present" << ends;
			return ost.str();
		default:
			return 0;
	}
}

char *
BinaryValueDescription_PregnancyStatus(Uint16 value)
{
	ostrstream ost;
	switch (value) {
		case 0x0001:
			ost << "Not Pregnant" << ends;
			return ost.str();
		case 0x0002:
			ost << "Possibly Pregnant" << ends;
			return ost.str();
		case 0x0003:
			ost << "Definitely Pregnant" << ends;
			return ost.str();
		case 0x0004:
			ost << "Unknown" << ends;
			return ost.str();
		default:
			return 0;
	}
}

char *
BinaryValueDescription_RegionSpatialFormat(Uint16 value)
{
	ostrstream ost;
	switch (value) {
		case 0x0000:
			ost << "None" << ends;
			return ost.str();
		case 0x0001:
			ost << "2D (Tissue or Flow)" << ends;
			return ost.str();
		case 0x0002:
			ost << "M-Mode (Tissue or Flow)" << ends;
			return ost.str();
		case 0x0003:
			ost << "Spectral (Tissue or Flow)" << ends;
			return ost.str();
		case 0x0004:
			ost << "Wave Form" << ends;
			return ost.str();
		case 0x0005:
			ost << "Graphics" << ends;
			return ost.str();
		default:
			return 0;
	}
}

char *
BinaryValueDescription_RegionDataType(Uint16 value)
{
	ostrstream ost;
	switch (value) {
		case 0x0000:
			ost << "None" << ends;
			return ost.str();
		case 0x0001:
			ost << "Tissue" << ends;
			return ost.str();
		case 0x0002:
			ost << "Color Flow" << ends;
			return ost.str();
		case 0x0003:
			ost << "PW Spectral Doppler" << ends;
			return ost.str();
		case 0x0004:
			ost << "CW Spectral Doppler" << ends;
			return ost.str();
		case 0x0005:
			ost << "Doppler Mean Trace" << ends;
			return ost.str();
		case 0x0006:
			ost << "Doppler Mode Trace" << ends;
			return ost.str();
		case 0x0007:
			ost << "Doppler Max Trace" << ends;
			return ost.str();
		case 0x0008:
			ost << "Volume Trace" << ends;
			return ost.str();
		case 0x0009:
			ost << "d(volume)/dt Trace" << ends;
			return ost.str();
		case 0x000a:
			ost << "ECG Trace" << ends;
			return ost.str();
		case 0x000b:
			ost << "Pulse Trace" << ends;
			return ost.str();
		case 0x000c:
			ost << "Phonocardiogram Trace" << ends;
			return ost.str();
		case 0x000d:
			ost << "Gray Bar" << ends;
			return ost.str();
		case 0x000e:
			ost << "Color Bar" << ends;
			return ost.str();
		case 0x000f:
			ost << "Integrated Backscatter" << ends;
			return ost.str();
		case 0x0010:
			ost << "Area Trace" << ends;
			return ost.str();
		case 0x0011:
			ost << "d(area)/dt" << ends;
			return ost.str();
		case 0x0012:
			ost << "Other Physiological Amplitude vs. Time Input" << ends;
			return ost.str();
		default:
			return 0;
	}
}

char *
BinaryBitMapDescription_RegionFlags(Uint16 value)
{
	Uint16 validmask=0;
	ostrstream ost;
	{
		validmask|=(1<<0);
		Uint16 bitvalue=value&(1<<0);
		ost << "Priority(" << (bitvalue ? "Low" : "High") << ") " << ends;
	}
	{
		validmask|=(1<<1);
		Uint16 bitvalue=value&(1<<1);
		ost << "Scaling Protection(" << (bitvalue ? "Protected" : "Not Protected") << ") " << ends;
	}
	{
		validmask|=(1<<2);
		Uint16 bitvalue=value&(1<<2);
		ost << "Doppler Scale Type(" << (bitvalue ? "Frequency" : "Velocity") << ") " << ends;
	}
	{
		validmask|=(1<<3);
		Uint16 bitvalue=value&(1<<3);
		ost << "Scrolling Region(" << (bitvalue ? "Scrolling" : "Not Scrolling") << ") " << ends;
	}
	{
		validmask|=(1<<4);
		Uint16 bitvalue=value&(1<<4);
		ost << "Sweeping Region(" << (bitvalue ? "Sweeping" : "Not Sweeping") << ") " << ends;
	}
	if (value&~validmask)
		return 0;
	else
		return ost.str();
}

char *
BinaryValueDescription_PixelComponentOrganization(Uint16 value)
{
	ostrstream ost;
	switch (value) {
		case 0x0000:
			ost << "Bit Aligned Positions" << ends;
			return ost.str();
		case 0x0001:
			ost << "Ranges" << ends;
			return ost.str();
		case 0x0002:
			ost << "Table Look Up" << ends;
			return ost.str();
		case 0x0003:
			ost << "Code Sequence Look Up" << ends;
			return ost.str();
		default:
			return 0;
	}
}

char *
BinaryValueDescription_PixelComponentPhysicalUnits(Uint16 value)
{
	ostrstream ost;
	switch (value) {
		case 0x0000:
			ost << "None" << ends;
			return ost.str();
		case 0x0001:
			ost << "Percent" << ends;
			return ost.str();
		case 0x0002:
			ost << "dB" << ends;
			return ost.str();
		case 0x0003:
			ost << "cm" << ends;
			return ost.str();
		case 0x0004:
			ost << "seconds" << ends;
			return ost.str();
		case 0x0005:
			ost << "hertz(seconds-1)" << ends;
			return ost.str();
		case 0x0006:
			ost << "dB/seconds" << ends;
			return ost.str();
		case 0x0007:
			ost << "cm/sec" << ends;
			return ost.str();
		case 0x0008:
			ost << "cm2" << ends;
			return ost.str();
		case 0x0009:
			ost << "cm2/sec" << ends;
			return ost.str();
		case 0x000a:
			ost << "cm3" << ends;
			return ost.str();
		case 0x000b:
			ost << "cm3/sec" << ends;
			return ost.str();
		case 0x000c:
			ost << "degrees" << ends;
			return ost.str();
		default:
			return 0;
	}
}

char *
BinaryValueDescription_PixelComponentDataType(Uint16 value)
{
	ostrstream ost;
	switch (value) {
		case 0x0000:
			ost << "None" << ends;
			return ost.str();
		case 0x0001:
			ost << "Tissue" << ends;
			return ost.str();
		case 0x0002:
			ost << "Spectral Doppler" << ends;
			return ost.str();
		case 0x0003:
			ost << "Color Flow Velocity" << ends;
			return ost.str();
		case 0x0004:
			ost << "Color Flow Variance" << ends;
			return ost.str();
		case 0x0005:
			ost << "Color Flow Intensity" << ends;
			return ost.str();
		case 0x0006:
			ost << "Gray Bar" << ends;
			return ost.str();
		case 0x0007:
			ost << "Color Bar" << ends;
			return ost.str();
		case 0x0008:
			ost << "Integrated Backscatter" << ends;
			return ost.str();
		case 0x0009:
			ost << "Computed Border" << ends;
			return ost.str();
		case 0x000A:
			ost << "Tissue Classification" << ends;
			return ost.str();
		default:
			return 0;
	}
}

char *
BinaryValueDescription_PixelRepresentation(Uint16 value)
{
	ostrstream ost;
	switch (value) {
		case 0x0000:
			ost << "unsigned" << ends;
			return ost.str();
		case 0x0001:
			ost << "signed" << ends;
			return ost.str();
		default:
			return 0;
	}
}

char *
BinaryValueDescription_PixelRepresentationUnsigned(Uint16 value)
{
	ostrstream ost;
	switch (value) {
		case 0x0000:
			ost << "unsigned" << ends;
			return ost.str();
		default:
			return 0;
	}
}

char *
BinaryValueDescription_PlanarConfiguration(Uint16 value)
{
	ostrstream ost;
	switch (value) {
		case 0x0000:
			ost << "sequential planes" << ends;
			return ost.str();
		case 0x0001:
			ost << "contiguous planes" << ends;
			return ost.str();
		default:
			return 0;
	}
}

char *
BinaryValueDescription_USPlanarConfiguration(Uint16 value)
{
	ostrstream ost;
	switch (value) {
		case 0x0000:
			ost << "sequential planes" << ends;
			return ost.str();
		case 0x0001:
			ost << "contiguous planes" << ends;
			return ost.str();
		default:
			return 0;
	}
}

char *
BinaryValueDescription_SamplesPerPixelIsOne(Uint16 value)
{
	ostrstream ost;
	switch (value) {
		case 0x0001:
			ost << "0x0001" << ends;
			return ost.str();
		default:
			return 0;
	}
}

char *
BinaryValueDescription_SamplesPerPixelIsThree(Uint16 value)
{
	ostrstream ost;
	switch (value) {
		case 0x0003:
			ost << "0x0003" << ends;
			return ost.str();
		default:
			return 0;
	}
}

char *
BinaryValueDescription_SamplesPerPixelIsOneOrThree(Uint16 value)
{
	ostrstream ost;
	switch (value) {
		case 0x0001:
			ost << "0x0001" << ends;
			return ost.str();
		case 0x0003:
			ost << "0x0003" << ends;
			return ost.str();
		default:
			return 0;
	}
}

char *
BinaryValueDescription_SamplesPerPixelUsedIsTwo(Uint16 value)
{
	ostrstream ost;
	switch (value) {
		case 0x0002:
			ost << "0x0002" << ends;
			return ost.str();
		default:
			return 0;
	}
}

char *
BinaryValueDescription_PlanarConfigurationIsColorByPlane(Uint16 value)
{
	ostrstream ost;
	switch (value) {
		case 0x0001:
			ost << "0x0001" << ends;
			return ost.str();
		default:
			return 0;
	}
}

char *
BinaryValueDescription_PlanarConfigurationIsColorByPixel(Uint16 value)
{
	ostrstream ost;
	switch (value) {
		case 0x0000:
			ost << "0x0000" << ends;
			return ost.str();
		default:
			return 0;
	}
}

char *
BinaryValueDescription_PlanarConfigurationIsColorByPlaneOrPixel(Uint16 value)
{
	ostrstream ost;
	switch (value) {
		case 0x0000:
			ost << "0x0000" << ends;
			return ost.str();
		case 0x0001:
			ost << "0x0001" << ends;
			return ost.str();
		default:
			return 0;
	}
}

char *
BinaryValueDescription_BitsAre32(Uint16 value)
{
	ostrstream ost;
	switch (value) {
		case 32:
			ost << "32" << ends;
			return ost.str();
		default:
			return 0;
	}
}

char *
BinaryValueDescription_BitsAre64(Uint16 value)
{
	ostrstream ost;
	switch (value) {
		case 64:
			ost << "64" << ends;
			return ost.str();
		default:
			return 0;
	}
}

char *
BinaryValueDescription_BitsAre16(Uint16 value)
{
	ostrstream ost;
	switch (value) {
		case 0x0010:
			ost << "0x0010" << ends;
			return ost.str();
		default:
			return 0;
	}
}

char *
BinaryValueDescription_BitsAre15(Uint16 value)
{
	ostrstream ost;
	switch (value) {
		case 0x000f:
			ost << "0x000f" << ends;
			return ost.str();
		default:
			return 0;
	}
}

char *
BinaryValueDescription_BitsAre8(Uint16 value)
{
	ostrstream ost;
	switch (value) {
		case 0x0008:
			ost << "0x0008" << ends;
			return ost.str();
		default:
			return 0;
	}
}

char *
BinaryValueDescription_BitsAre7(Uint16 value)
{
	ostrstream ost;
	switch (value) {
		case 0x0007:
			ost << "0x0007" << ends;
			return ost.str();
		default:
			return 0;
	}
}

char *
BinaryValueDescription_BitsAre12Or16(Uint16 value)
{
	ostrstream ost;
	switch (value) {
		case 0x000c:
			ost << "0x000c" << ends;
			return ost.str();
		case 0x0010:
			ost << "0x0010" << ends;
			return ost.str();
		default:
			return 0;
	}
}

char *
BinaryValueDescription_BitsAre11Or15(Uint16 value)
{
	ostrstream ost;
	switch (value) {
		case 0x000b:
			ost << "0x000b" << ends;
			return ost.str();
		case 0x000f:
			ost << "0x000f" << ends;
			return ost.str();
		default:
			return 0;
	}
}

char *
BinaryValueDescription_BitsAre8Or16(Uint16 value)
{
	ostrstream ost;
	switch (value) {
		case 0x0008:
			ost << "0x0008" << ends;
			return ost.str();
		case 0x0010:
			ost << "0x0010" << ends;
			return ost.str();
		default:
			return 0;
	}
}

char *
BinaryValueDescription_BitsAre16Or32(Uint16 value)
{
	ostrstream ost;
	switch (value) {
		case 0x0010:
			ost << "0x0010" << ends;
			return ost.str();
		case 0x0020:
			ost << "0x0020" << ends;
			return ost.str();
		default:
			return 0;
	}
}

char *
BinaryValueDescription_BitsAre7Or15(Uint16 value)
{
	ostrstream ost;
	switch (value) {
		case 0x0007:
			ost << "0x0007" << ends;
			return ost.str();
		case 0x000f:
			ost << "0x000f" << ends;
			return ost.str();
		default:
			return 0;
	}
}

char *
BinaryValueDescription_BitsAre15Or31(Uint16 value)
{
	ostrstream ost;
	switch (value) {
		case 0x000f:
			ost << "0x000f" << ends;
			return ost.str();
		case 0x001f:
			ost << "0x001f" << ends;
			return ost.str();
		default:
			return 0;
	}
}

char *
BinaryValueDescription_BitsAre8Or10Or12Or16(Uint16 value)
{
	ostrstream ost;
	switch (value) {
		case 0x0008:
			ost << "0x0008" << ends;
			return ost.str();
		case 0x000a:
			ost << "0x000a" << ends;
			return ost.str();
		case 0x000c:
			ost << "0x000c" << ends;
			return ost.str();
		case 0x0010:
			ost << "0x0010" << ends;
			return ost.str();
		default:
			return 0;
	}
}

char *
BinaryValueDescription_BitsAre7Or9Or11Or15(Uint16 value)
{
	ostrstream ost;
	switch (value) {
		case 0x0007:
			ost << "0x0007" << ends;
			return ost.str();
		case 0x0009:
			ost << "0x0009" << ends;
			return ost.str();
		case 0x000b:
			ost << "0x000b" << ends;
			return ost.str();
		case 0x000f:
			ost << "0x000f" << ends;
			return ost.str();
		default:
			return 0;
	}
}

char *
BinaryValueDescription_BitsAre8Or12To16(Uint16 value)
{
	ostrstream ost;
	switch (value) {
		case 0x0008:
			ost << "0x0008" << ends;
			return ost.str();
		case 0x000c:
			ost << "0x000c" << ends;
			return ost.str();
		case 0x000d:
			ost << "0x000d" << ends;
			return ost.str();
		case 0x000e:
			ost << "0x000e" << ends;
			return ost.str();
		case 0x000f:
			ost << "0x000f" << ends;
			return ost.str();
		case 0x0010:
			ost << "0x0010" << ends;
			return ost.str();
		default:
			return 0;
	}
}

char *
BinaryValueDescription_BitsAre7Or11To15(Uint16 value)
{
	ostrstream ost;
	switch (value) {
		case 0x0007:
			ost << "0x0007" << ends;
			return ost.str();
		case 0x000a:
			ost << "0x000a" << ends;
			return ost.str();
		case 0x000b:
			ost << "0x000b" << ends;
			return ost.str();
		case 0x000c:
			ost << "0x000c" << ends;
			return ost.str();
		case 0x000d:
			ost << "0x000d" << ends;
			return ost.str();
		case 0x000e:
			ost << "0x000e" << ends;
			return ost.str();
		case 0x000f:
			ost << "0x000f" << ends;
			return ost.str();
		default:
			return 0;
	}
}

char *
BinaryValueDescription_BitsAre8Or12Or16(Uint16 value)
{
	ostrstream ost;
	switch (value) {
		case 0x0008:
			ost << "0x0008" << ends;
			return ost.str();
		case 0x000c:
			ost << "0x000c" << ends;
			return ost.str();
		case 0x0010:
			ost << "0x0010" << ends;
			return ost.str();
		default:
			return 0;
	}
}

char *
BinaryValueDescription_BitsAre7Or11Or15(Uint16 value)
{
	ostrstream ost;
	switch (value) {
		case 0x0007:
			ost << "0x0007" << ends;
			return ost.str();
		case 0x000b:
			ost << "0x000b" << ends;
			return ost.str();
		case 0x000f:
			ost << "0x000f" << ends;
			return ost.str();
		default:
			return 0;
	}
}

char *
BinaryValueDescription_BitsAre6To16(Uint16 value)
{
	ostrstream ost;
	switch (value) {
		case 0x0006:
			ost << "0x0006" << ends;
			return ost.str();
		case 0x0007:
			ost << "0x0007" << ends;
			return ost.str();
		case 0x0008:
			ost << "0x0008" << ends;
			return ost.str();
		case 0x0009:
			ost << "0x0009" << ends;
			return ost.str();
		case 0x000a:
			ost << "0x000a" << ends;
			return ost.str();
		case 0x000b:
			ost << "0x000b" << ends;
			return ost.str();
		case 0x000c:
			ost << "0x000c" << ends;
			return ost.str();
		case 0x000d:
			ost << "0x000d" << ends;
			return ost.str();
		case 0x000e:
			ost << "0x000e" << ends;
			return ost.str();
		case 0x000f:
			ost << "0x000f" << ends;
			return ost.str();
		case 0x0010:
			ost << "0x0010" << ends;
			return ost.str();
		default:
			return 0;
	}
}

char *
BinaryValueDescription_BitsAre5To15(Uint16 value)
{
	ostrstream ost;
	switch (value) {
		case 0x0005:
			ost << "0x0005" << ends;
			return ost.str();
		case 0x0006:
			ost << "0x0006" << ends;
			return ost.str();
		case 0x0007:
			ost << "0x0007" << ends;
			return ost.str();
		case 0x0008:
			ost << "0x0008" << ends;
			return ost.str();
		case 0x0009:
			ost << "0x0009" << ends;
			return ost.str();
		case 0x000a:
			ost << "0x000a" << ends;
			return ost.str();
		case 0x000b:
			ost << "0x000b" << ends;
			return ost.str();
		case 0x000c:
			ost << "0x000c" << ends;
			return ost.str();
		case 0x000d:
			ost << "0x000d" << ends;
			return ost.str();
		case 0x000e:
			ost << "0x000e" << ends;
			return ost.str();
		case 0x000f:
			ost << "0x000f" << ends;
			return ost.str();
		default:
			return 0;
	}
}

char *
BinaryValueDescription_BitsAre8To15(Uint16 value)
{
	ostrstream ost;
	switch (value) {
		case 0x0008:
			ost << "0x0008" << ends;
			return ost.str();
		case 0x0009:
			ost << "0x0009" << ends;
			return ost.str();
		case 0x000A:
			ost << "0x000A" << ends;
			return ost.str();
		case 0x000B:
			ost << "0x000B" << ends;
			return ost.str();
		case 0x000C:
			ost << "0x000C" << ends;
			return ost.str();
		case 0x000D:
			ost << "0x000D" << ends;
			return ost.str();
		case 0x000E:
			ost << "0x000E" << ends;
			return ost.str();
		case 0x000F:
			ost << "0x000F" << ends;
			return ost.str();
		default:
			return 0;
	}
}

char *
BinaryValueDescription_BitsAre7To15(Uint16 value)
{
	ostrstream ost;
	switch (value) {
		case 0x0007:
			ost << "0x0007" << ends;
			return ost.str();
		case 0x0008:
			ost << "0x0008" << ends;
			return ost.str();
		case 0x0009:
			ost << "0x0009" << ends;
			return ost.str();
		case 0x000A:
			ost << "0x000A" << ends;
			return ost.str();
		case 0x000B:
			ost << "0x000B" << ends;
			return ost.str();
		case 0x000C:
			ost << "0x000C" << ends;
			return ost.str();
		case 0x000D:
			ost << "0x000D" << ends;
			return ost.str();
		case 0x000E:
			ost << "0x000E" << ends;
			return ost.str();
		case 0x000F:
			ost << "0x000F" << ends;
			return ost.str();
		default:
			return 0;
	}
}

char *
BinaryValueDescription_BitsAre8To16(Uint16 value)
{
	ostrstream ost;
	switch (value) {
		case 0x0008:
			ost << "0x0008" << ends;
			return ost.str();
		case 0x0009:
			ost << "0x0009" << ends;
			return ost.str();
		case 0x000A:
			ost << "0x000A" << ends;
			return ost.str();
		case 0x000B:
			ost << "0x000B" << ends;
			return ost.str();
		case 0x000C:
			ost << "0x000C" << ends;
			return ost.str();
		case 0x000D:
			ost << "0x000D" << ends;
			return ost.str();
		case 0x000E:
			ost << "0x000E" << ends;
			return ost.str();
		case 0x000F:
			ost << "0x000F" << ends;
			return ost.str();
		case 0x0010:
			ost << "0x0010" << ends;
			return ost.str();
		default:
			return 0;
	}
}

char *
BinaryValueDescription_BitsAre9To16(Uint16 value)
{
	ostrstream ost;
	switch (value) {
		case 0x0009:
			ost << "0x0009" << ends;
			return ost.str();
		case 0x000A:
			ost << "0x000A" << ends;
			return ost.str();
		case 0x000B:
			ost << "0x000B" << ends;
			return ost.str();
		case 0x000C:
			ost << "0x000C" << ends;
			return ost.str();
		case 0x000D:
			ost << "0x000D" << ends;
			return ost.str();
		case 0x000E:
			ost << "0x000E" << ends;
			return ost.str();
		case 0x000F:
			ost << "0x000F" << ends;
			return ost.str();
		case 0x0010:
			ost << "0x0010" << ends;
			return ost.str();
		default:
			return 0;
	}
}

char *
BinaryValueDescription_BitsAre10To16(Uint16 value)
{
	ostrstream ost;
	switch (value) {
		case 0x000A:
			ost << "0x000A" << ends;
			return ost.str();
		case 0x000B:
			ost << "0x000B" << ends;
			return ost.str();
		case 0x000C:
			ost << "0x000C" << ends;
			return ost.str();
		case 0x000D:
			ost << "0x000D" << ends;
			return ost.str();
		case 0x000E:
			ost << "0x000E" << ends;
			return ost.str();
		case 0x000F:
			ost << "0x000F" << ends;
			return ost.str();
		case 0x0010:
			ost << "0x0010" << ends;
			return ost.str();
		default:
			return 0;
	}
}

char *
BinaryValueDescription_BitsAre12To16(Uint16 value)
{
	ostrstream ost;
	switch (value) {
		case 0x000C:
			ost << "0x000C" << ends;
			return ost.str();
		case 0x000D:
			ost << "0x000D" << ends;
			return ost.str();
		case 0x000E:
			ost << "0x000E" << ends;
			return ost.str();
		case 0x000F:
			ost << "0x000F" << ends;
			return ost.str();
		case 0x0010:
			ost << "0x0010" << ends;
			return ost.str();
		default:
			return 0;
	}
}

char *
BinaryValueDescription_BitsAre11To15(Uint16 value)
{
	ostrstream ost;
	switch (value) {
		case 0x000B:
			ost << "0x000B" << ends;
			return ost.str();
		case 0x000C:
			ost << "0x000C" << ends;
			return ost.str();
		case 0x000D:
			ost << "0x000D" << ends;
			return ost.str();
		case 0x000E:
			ost << "0x000E" << ends;
			return ost.str();
		case 0x000F:
			ost << "0x000F" << ends;
			return ost.str();
		default:
			return 0;
	}
}

char *
BinaryValueDescription_BitsAre1Or8(Uint16 value)
{
	ostrstream ost;
	switch (value) {
		case 0x0001:
			ost << "0x0001" << ends;
			return ost.str();
		case 0x0008:
			ost << "0x0008" << ends;
			return ost.str();
		default:
			return 0;
	}
}

char *
BinaryValueDescription_BitsAre0Or7(Uint16 value)
{
	ostrstream ost;
	switch (value) {
		case 0x0001:
			ost << "0x0001" << ends;
			return ost.str();
		case 0x0007:
			ost << "0x0007" << ends;
			return ost.str();
		default:
			return 0;
	}
}

char *
BinaryValueDescription_CurveDataValueRepresentation(Uint16 value)
{
	ostrstream ost;
	switch (value) {
		case 0x0000:
			ost << "Unsigned Short(US)" << ends;
			return ost.str();
		case 0x0001:
			ost << "Signed Short(SS)" << ends;
			return ost.str();
		case 0x0002:
			ost << "Floating Point Single(FL)" << ends;
			return ost.str();
		case 0x0003:
			ost << "Floating Point Double(FD)" << ends;
			return ost.str();
		case 0x0004:
			ost << "Signed Long(SL)" << ends;
			return ost.str();
		default:
			return 0;
	}
}

char *
BinaryValueDescription_CurveDataDescriptor(Uint16 value)
{
	ostrstream ost;
	switch (value) {
		case 0x0000:
			ost << "Interval Spacing" << ends;
			return ost.str();
		case 0x0001:
			ost << "Values" << ends;
			return ost.str();
		default:
			return 0;
	}
}

char *
BinaryValueDescription_AudioType(Uint16 value)
{
	ostrstream ost;
	switch (value) {
		case 0x0000:
			ost << "None" << ends;
			return ost.str();
		case 0x0001:
			ost << "Doppler Audio" << ends;
			return ost.str();
		case 0x0002:
			ost << "Voice Audio" << ends;
			return ost.str();
		case 0x0003:
			ost << "Phono Audio" << ends;
			return ost.str();
		default:
			return 0;
	}
}

char *
BinaryValueDescription_AudioSampleFormat(Uint16 value)
{
	ostrstream ost;
	switch (value) {
		case 0x0000:
			ost << "16 Bit Signed LSB First Interleaved Per Channel" << ends;
			return ost.str();
		case 0x0001:
			ost << "8 bit Signed Interleaved Per Channel" << ends;
			return ost.str();
		default:
			return 0;
	}
}

char *
BinaryValueDescription_NumberOfChannels(Uint16 value)
{
	ostrstream ost;
	switch (value) {
		case 0x0000:
			ost << "Mono" << ends;
			return ost.str();
		case 0x0001:
			ost << "Stereo" << ends;
			return ost.str();
		default:
			return 0;
	}
}

char *
BinaryValueDescription_UltrasoundColorDataPresent(Uint16 value)
{
	ostrstream ost;
	switch (value) {
		case 0x0000:
			ost << "Ultrasound color data not present in image" << ends;
			return ost.str();
		case 0x0001:
			ost << "Ultrasound color data is present in image" << ends;
			return ost.str();
		default:
			return 0;
	}
}

char *
BinaryValueDescription_PreferredPlaybackSequencing(Uint16 value)
{
	ostrstream ost;
	switch (value) {
		case 0x0000:
			ost << "Looping" << ends;
			return ost.str();
		case 0x0001:
			ost << "Sweeping" << ends;
			return ost.str();
		default:
			return 0;
	}
}

char *
BinaryValueDescription_PreferredPlaybackSequencingForHangingProtocol(Uint16 value)
{
	ostrstream ost;
	switch (value) {
		case 0x0000:
			ost << "Looping" << ends;
			return ost.str();
		case 0x0001:
			ost << "Sweeping" << ends;
			return ost.str();
		case 0x0002:
			ost << "Stop" << ends;
			return ost.str();
		default:
			return 0;
	}
}

char *
BinaryValueDescription_PreferredPlaybackSequencingForStructuredDisplay(Uint16 value)
{
	ostrstream ost;
	switch (value) {
		case 0x0000:
			ost << "Looping" << ends;
			return ost.str();
		case 0x0001:
			ost << "Sweeping" << ends;
			return ost.str();
		case 0x0002:
			ost << "Stop" << ends;
			return ost.str();
		default:
			return 0;
	}
}

char *
BinaryValueDescription_FileSetConsistencyFlag(Uint16 value)
{
	ostrstream ost;
	switch (value) {
		case 0x0000:
			ost << "No known inconsistencies" << ends;
			return ost.str();
		case 0xffff:
			ost << "Inconsistencies may be present" << ends;
			return ost.str();
		default:
			return 0;
	}
}

char *
BinaryValueDescription_RecordInUseFlag(Uint16 value)
{
	ostrstream ost;
	switch (value) {
		case 0x0000:
			ost << "Record is inactive" << ends;
			return ost.str();
		case 0xffff:
			ost << "Record is in use" << ends;
			return ost.str();
		default:
			return 0;
	}
}

char *
BinaryValueDescription_PixelIntensityRelationshipSign(Uint16 value)
{
	ostrstream ost;
	switch (value) {
		case 0x0001:
			ost << "Lower pixel values correspond to lower X-Ray intensity" << ends;
			return ost.str();
		case 0xffff:
			ost << "Higher pixel values correspond to lower X-Ray intensity" << ends;
			return ost.str();
		default:
			return 0;
	}
}

char *
BinaryValueDescription_AllPossibleOverlayGroups(Uint16 value)
{
	ostrstream ost;
	switch (value) {
		case 0x6000:
			ost << "0x6000" << ends;
			return ost.str();
		case 0x6002:
			ost << "0x6002" << ends;
			return ost.str();
		case 0x6004:
			ost << "0x6004" << ends;
			return ost.str();
		case 0x6006:
			ost << "0x6006" << ends;
			return ost.str();
		case 0x6008:
			ost << "0x6008" << ends;
			return ost.str();
		case 0x600a:
			ost << "0x600a" << ends;
			return ost.str();
		case 0x600c:
			ost << "0x600c" << ends;
			return ost.str();
		case 0x600e:
			ost << "0x600e" << ends;
			return ost.str();
		case 0x6010:
			ost << "0x6010" << ends;
			return ost.str();
		case 0x6012:
			ost << "0x6012" << ends;
			return ost.str();
		case 0x6014:
			ost << "0x6014" << ends;
			return ost.str();
		case 0x6016:
			ost << "0x6016" << ends;
			return ost.str();
		case 0x6018:
			ost << "0x6018" << ends;
			return ost.str();
		case 0x601a:
			ost << "0x601a" << ends;
			return ost.str();
		case 0x601c:
			ost << "0x601c" << ends;
			return ost.str();
		case 0x601e:
			ost << "0x601e" << ends;
			return ost.str();
		default:
			return 0;
	}
}

char *
BinaryValueDescription_Two(Uint16 value)
{
	ostrstream ost;
	switch (value) {
		case 2:
			ost << "2" << ends;
			return ost.str();
		default:
			return 0;
	}
}

char *
BinaryValueDescription_ImageRotationValues(Uint16 value)
{
	ostrstream ost;
	switch (value) {
		case 0:
			ost << "0" << ends;
			return ost.str();
		case 90:
			ost << "90" << ends;
			return ost.str();
		case 180:
			ost << "180" << ends;
			return ost.str();
		case 270:
			ost << "270" << ends;
			return ost.str();
		default:
			return 0;
	}
}


#endif /* __Header_binvald__ */
